<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Filesystem Explorer</title>
    <style>
        /* Stili base per il corpo e il layout generale */
        body {
            margin: 0;
            padding: 0;
            font-family: sans-serif;
            display: flex; /* Usa Flexbox per un layout a due colonne */
            flex-direction: column; /* Imposta il corpo come flex container verticale */
            height: 100vh; /* Occupa l'intera altezza della viewport */
            overflow: hidden; /* Previene lo scroll sulla pagina principale */
        }
        #content-area {
            display: flex; /* Usa Flexbox per i pannelli sinistro e principale */
            flex-grow: 1; /* Fa in modo che l'area dei contenuti occupi lo spazio disponibile */
            overflow: hidden; /* Nasconde l'overflow per i pannelli interni */
            position: relative; /* Necessario per posizionare l'overlay di caricamento e le modali */
        }
        #left-panel {
            width: 25%; /* 25% della larghezza */
            border-right: 1px solid #ccc; /* Separatore visivo */
            box-sizing: border-box; /* Include bordo e padding nella larghezza */
            display: flex;
            flex-direction: column; /* Elementi impilati verticalmente */
            overflow-y: auto; /* Permette lo scroll verticale nel pannello sinistro */
            z-index: 1; /* Assicura che sia sotto l'overlay di caricamento e le modali */
        }
        #main-panel {
            width: 75%; /* 75% della larghezza */
            display: flex;
            flex-direction: column; /* Elementi impilati verticalmente */
            overflow-y: auto; /* Permette lo scroll verticale nel pannello principale */
             z-index: 1; /* Assicura che sia sotto l'overlay di caricamento e le modali */
        }
        iframe {
            flex-grow: 1; /* Fa in modo che l'iframe occupi lo spazio disponibile */
            border: none; /* Rimuove il bordo predefinito dell'iframe */
            width: 100%; /* Occupa l'intera larghezza del pannello */
            height: 100%; /* Riempi lo spazio verticale disponibile */
        }
        header {
            background-color: #f0f0f0;
            padding: 10px;
            text-align: center;
            border-bottom: 1px solid #ccc;
            display: flex; /* Usa flexbox per allineare titolo e pulsanti */
            justify-content: space-between; /* Spazia gli elementi */
            align-items: center; /* Centra verticalmente */
        }
         header h2 {
             margin: 0; /* Rimuove margine predefinito dal titolo */
             flex-grow: 1; /* Permette al titolo di occupare lo spazio */
             text-align: center; /* Centra il titolo */
         }
         #main-panel header {
             justify-content: flex-start; /* Allinea a sinistra per fare spazio al pulsante */
         }
         #main-panel header h2 {
              text-align: left; /* Allinea il titolo a sinistra */
              margin-right: 10px; /* Spazio tra titolo e pulsante */
         }
         #main-panel header button {
             padding: 5px 10px;
             cursor: pointer;
             border: 1px solid #ccc;
             border-radius: 4px;
             background-color: #e0e0e0;
         }
          #main-panel header button:hover {
              background-color: #d5d5d5;
          }
          #main-panel header button:disabled {
              cursor: not-allowed;
              opacity: 0.5;
          }


        /* --- Stili per l'Area Messaggi/Cronologia --- */
        #message-history-area {
            background-color: #f9f9f9; /* Sfondo leggero */
            border-top: 1px solid #ccc; /* Bordo superiore */
            font-size: 0.9em;
            display: flex;
            flex-direction: column; /* Contenuto impilato verticalmente */
            max-height: 30px; /* Altezza massima quando compressa (circa 1 riga) */
            overflow: hidden; /* Nasconde il contenuto in eccesso quando compressa */
            transition: max-height 0.3s ease; /* Animazione per l'espansione/compressione */
             z-index: 10; /* Assicura che sia sopra l'overlay di caricamento e le modali */
        }

        #message-history-area.expanded {
            max-height: 200px; /* Altezza massima quando espansa */
            overflow-y: auto; /* Permette lo scroll verticale quando espansa */
        }

        #message-history-header {
            background-color: #e0e0e0; /* Sfondo leggermente più scuro per l'header */
            padding: 5px 10px;
            font-weight: bold;
            cursor: pointer; /* Indica cliccabilità */
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0; /* Impedisce all'header di rimpicciolirsi */
        }

        #message-history-toggle {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2em; /* Dimensione icona */
            padding: 0; /* Rimuove padding extra */
            margin-left: 10px;
        }

        #message-list {
            list-style: none;
            padding: 0 10px 10px 10px; /* Padding interno */
            margin: 0; /* Rimuove margine predefinito */
        }

        #message-list li {
            margin-bottom: 5px; /* Spazio tra i messaggi */
            padding-bottom: 5px;
            border-bottom: 1px dotted #ccc; /* Separatore leggero */
            word-break: break-word; /* Permette al testo lungo di andare a capo */
        }

        #message-list li:last-child {
            border-bottom: none; /* Nessun bordo per l'ultimo messaggio */
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .message-timestamp {
            font-weight: normal;
            color: #666;
            margin-right: 10px;
             white-space: nowrap; /* Impedisce al timestamp di andare a capo */
        }
        /* --- Fine Stili Area Messaggi/Cronologia --- */


        /* --- Stili per la Progress Bar di Upload --- */
        #upload-progress-box {
            position: fixed; /* Posizionamento fisso rispetto alla viewport */
            bottom: 40px; /* Spazio sopra l'area messaggi */
            right: 20px; /* 20px da destra */
            width: 300px; /* Larghezza fissa del riquadro */
            background-color: #fff; /* Sfondo bianco */
            border: 1px solid #ccc; /* Bordo sottile */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2); /* Ombra leggera */
            z-index: 1000; /* Assicura che sia sopra gli altri contenuti */
            font-family: sans-serif;
            font-size: 0.9em;
            transition: all 0.3s ease; /* Animazione per le transizioni */
            display: none; /* Nascosto di default */
            border-radius: 8px; /* Angoli arrotondati */
            max-height: 40px; /* Altezza massima quando iconizzato */
            overflow: hidden; /* Nasconde il contenuto extra quando iconizzato */
        }

        #upload-progress-box.expanded {
            max-height: 300px; /* Altezza massima quando espansa */
            overflow-y: auto; /* Permette lo scroll verticale quando espansa */
        }

        #upload-progress-header {
            background-color: #f0f0f0;
            padding: 5px 10px;
            border-bottom: 1px solid #ccc;
            cursor: pointer; /* Indica cliccabilità */
            display: flex;
            justify-content: space-between; /* Spazio tra titolo e pulsante */
            align-items: center;
            font-weight: bold;
            border-top-left-radius: 8px; /* Angoli arrotondati solo in alto */
            border-top-right-radius: 8px;
            flex-shrink: 0; /* Impedisce all'header di rimpicciolirsi */
        }

        #upload-progress-box:not(.expanded) #upload-progress-header {
             border-bottom: none; /* Rimuove il bordo inferiore quando iconizzato */
             border-bottom-left-radius: 8px; /* Angoli arrotondati anche in basso quando iconizzato */
             border-bottom-right-radius: 8px;
         }

        #upload-progress-header span {
             flex-grow: 1; /* Permette al testo di occupare lo spazio */
             white-space: nowrap; /* Evita che il testo vada a capo */
             overflow: hidden; /* Nasconde il testo che eccede */
             text-overflow: ellipsis; /* Aggiunge puntini di sospensione se il testo è troppo lungo */
             margin-right: 10px;
         }

        #upload-progress-toggle {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.2em; /* Dimensione icona */
            padding: 0; /* Rimuove padding extra */
        }

        #upload-items-container {
            padding: 10px;
            display: flex;
            flex-direction: column; /* Elementi upload impilati */
            gap: 10px; /* Spazio tra gli elementi upload */
        }

        .upload-item {
            border: 1px solid #ddd;
            padding: 8px;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        .upload-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .upload-file-name {
             font-weight: bold;
             white-space: nowrap;
             overflow: hidden;
             text-overflow: ellipsis;
             flex-grow: 1;
             margin-right: 10px;
         }

        .upload-cancel-button {
             background: none;
             border: none;
             cursor: pointer;
             font-size: 1em;
             color: #f44336; /* Rosso */
             padding: 0;
         }
        .upload-cancel-button:hover {
            color: #d32f2f; /* Rosso scuro */
        }

        .upload-progress-bar-container {
            width: 100%;
            background-color: #e0e0e0;
            border-radius: 5px;
            margin-top: 5px;
            overflow: hidden; /* Assicura che la barra non esca dai bordi */
        }

        .upload-progress-bar {
            height: 15px; /* Altezza ridotta per le singole barre */
            background-color: #4CAF50; /* Colore verde */
            width: 0%; /* Inizia da 0% */
            text-align: center;
            line-height: 15px;
            color: white;
            font-weight: bold;
            transition: width 0.3s ease; /* Animazione per il progresso */
            font-size: 0.8em; /* Dimensione font ridotta */
        }

        .upload-status-text {
            margin-top: 5px;
            font-style: italic;
            font-size: 0.8em;
        }
         /* Stile per upload completato */
        .upload-item.complete {
            border-color: #4CAF50; /* Verde */
            background-color: #e8f5e9; /* Verde chiaro */
        }
         /* Stile per upload fallito */
        .upload-item.failed {
            border-color: #f44336; /* Rosso */
            background-color: #ffebee; /* Rosso chiaro */
        }
         /* Stile per upload annullato */
        .upload-item.cancelled {
            border-color: #ff9800; /* Arancione */
            background-color: #fff3e0; /* Arancione chiaro */
        }


        /* --- Fine Stili Progress Bar --- */

        /* --- Stili per le Modali Generiche --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5); /* Sfondo semitrasparente */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000; /* Assicura che sia sopra tutto il resto */
            display: none; /* Nascosto di default */
        }

        .modal-content {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            width: 90%; /* Larghezza su mobile */
            max-width: 400px; /* Larghezza massima su desktop */
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .modal-content h3 {
            margin-top: 0;
            margin-bottom: 10px;
            text-align: center;
        }

        .modal-content label {
            font-weight: bold;
        }

        .modal-content input[type="text"],
        .modal-content input[type="range"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box; /* Include padding e bordo nella larghezza */
        }

        .modal-content .slider-value {
            text-align: center;
            font-weight: bold;
            margin-top: 5px;
        }
         .modal-content p {
             margin: 0;
             padding: 0;
             text-align: center;
         }


        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 15px;
        }

        .modal-actions button {
            padding: 8px 15px;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
        }

        .modal-actions button.primary {
            background-color: #4CAF50; /* Verde */
            color: white;
            border-color: #388E3C; /* Verde scuro */
        }
         .modal-actions button.primary:hover {
             background-color: #388E3C;
         }

        .modal-actions button.danger {
            background-color: #f44336; /* Rosso */
            color: white;
            border-color: #d32f2f; /* Rosso scuro */
        }
         .modal-actions button.danger:hover {
            background-color: #d32f2f;
         }

        .modal-actions button.secondary {
            background-color: #f0f0f0;
        }
         .modal-actions button.secondary:hover {
             background-color: #e0e0e0;
         }

        /* --- Fine Stili Modali Generiche --- */

        /* --- Stili per la Rotella di Caricamento Modale Granulare --- */
        #filelist-loading-overlay {
            position: absolute; /* Posizionato rispetto a #filelist-container */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.7); /* Sfondo bianco semitrasparente */
            display: none; /* Nascosto di default */
            justify-content: center; /* Centra il contenuto (spinner) orizzontalmente */
            align-items: center; /* Centra il contenuto (spinner) verticalmente */
            z-index: 2; /* Assicura che sia sopra l'iframe della lista file */
            pointer-events: auto; /* Permette di intercettare i click per bloccare l'interazione */
        }

        /* Il .spinner generico può rimanere per riuso, ma #loading-overlay è ora meno rilevante */
        .spinner {
            border: 8px solid #f3f3f3; /* Light grey */
            border-top: 8px solid #3498db; /* Blue */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 2s linear infinite; /* Animazione di rotazione */
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* --- Fine Stili Rotella di Caricamento Modale Granulare --- */

        /* Stili per la WebSocket Status Box */
        #websocket-status-box {
            position: fixed; /* Posizionamento fisso rispetto alla viewport */
            bottom: 10px; /* 10px dal fondo */
            left: 10px; /* 10px da sinistra */
            padding: 8px 12px; /* Spazio interno */
            border-radius: 5px; /* Angoli arrotondati */
            font-family: sans-serif;
            font-size: 0.9em;
            font-weight: bold;
            color: white;    /* Testo bianco di default */
            background-color: #555; /* Sfondo grigio di default */
            z-index: 1000; /* Assicura che sia sopra gli altri contenuti */
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); /* Ombra leggera */
            display: flex; /* Usa flexbox per allineare il testo */
            align-items: center; /* Centra verticalmente */
        }

        #websocket-status-box.status-green {
            background-color: #4CAF50; /* Verde */
        }

        #websocket-status-box.status-red {
            background-color: #f44336; /* Rosso */
        }

        #websocket-status-box.status-yellow {
            background-color: #ff9800; /* Giallo/Arancione per stato intermedio o warning */
        }
        /* Stili per il Toast */
        #toast-container {
            position: fixed;
            top: 20px; /* Adjust as needed */
            right: 20px; /* Adjust as needed */
            z-index: 3000; /* Ensure it's above everything */
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none; /* Allows clicks to pass through to elements behind */
        }

        .toast {
            background-color: #333;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transform: translateY(-20px);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            pointer-events: auto; /* Re-enable pointer events for the toast itself */
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }

        /* Tipi di toast */
        .toast-info {
            background-color: #2196F3; /* Blue */
        }
        .toast-success {
            background-color: #4CAF50; /* Green */
        }
        .toast-warning {
            background-color: #FFC107; /* Amber */
        }
        .toast-error {
            background-color: #f44336; /* Red */
        }
    </style>
</head>
<body>
    <div id="content-area">
        <div id="toast-container"></div> <div id="left-panel">
            <header><h2>Storages</h2></header> <iframe id="treeview-iframe" src="/treeview.html"></iframe>
        </div>
        <div id="main-panel">
            <header>
                <h2>File List</h2>
                <button id="create-folder-btn" style="display: none;">Nuova Cartella</button>
            </header>
            <div id="filelist-container" style="position: relative; flex-grow: 1; display: flex; flex-direction: column;">
                <iframe id="filelist-iframe" src="/filelist.html"></iframe>
                <div id="filelist-loading-overlay">
                    <div class="spinner"></div>
                </div>
            </div>
        </div>
        <div id="websocket-status-box">
                Stato Connessione: <span id="websocket-status-text">Connessione in corso...</span>
        </div>
        </div>

    <div id="message-history-area">
        <div id="message-history-header">
            <span>Cronologia Messaggi</span>
            <button id="message-history-toggle">▲</button>
        </div>
        <ul id="message-list">
        </ul>
    </div>

    <div id="upload-progress-box">
        <div id="upload-progress-header">
             <span id="upload-header-text">Upload</span>
            <button id="upload-progress-toggle">▲</button>
        </div>
        <div id="upload-items-container">
        </div>
    </div>

    <div id="chunk-size-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>Seleziona Dimensione Chunk</h3>
            <label for="chunk-size-slider">Dimensione Chunk:</label>
            <input type="range" id="chunk-size-slider" min="1" value="4194304"> <div class="slider-value" id="chunk-size-display">4 MB</div>

            <label for="parallel-chunks-slider">Chunk in Parallelo:</label>
            <input type="range" id="parallel-chunks-slider" min="1" max="16" value="4"> <div class="slider-value" id="parallel-chunks-display">4</div>

            <div class="modal-actions">
                <button id="cancel-modal-btn" class="secondary">Annulla</button>
                <button id="start-upload-btn" class="primary">Avvia Upload</button>
            </div>
        </div>
    </div>

    <div id="create-folder-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>Crea Nuova Cartella</h3>
            <label for="new-folder-name">Nome Cartella:</label>
            <input type="text" id="new-folder-name">
            <div class="modal-actions">
                <button id="cancel-create-folder-btn" class="secondary">Annulla</button>
                <button id="confirm-create-folder-btn" class="primary">Crea</button>
            </div>
        </div>
    </div>

    <div id="delete-confirm-modal" class="modal-overlay">
        <div class="modal-content">
            <h3>Conferma Cancellazione</h3>
            <p id="delete-item-name"></p>
            <p id="delete-warning-message">Sei sicuro di voler eliminare questo elemento? Questa azione non può essere annullata.</p>
            <div class="modal-actions">
                <button id="cancel-delete-btn" class="secondary">Annulla</button>
                <button id="confirm-delete-btn" class="danger">Elimina</button>
            </div>
        </div>
    </div>


    <script>
        // Script nella pagina principale per coordinare la comunicazione tra iframes e backend

        // --- Elementi dell'Area Messaggi/Cronologia ---
        const messageHistoryArea = document.getElementById('message-history-area');
        const messageHistoryHeader = document.getElementById('message-history-header');
        const messageHistoryToggle = document.getElementById('message-history-toggle');
        const messageList = document.getElementById('message-list');
        // --- Fine Elementi Area Messaggi/Cronologia ---


        // --- Elementi della Progress Box Upload ---
        const uploadProgressBox = document.getElementById('upload-progress-box');
        const uploadProgressHeader = document.getElementById('upload-progress-header');
        const uploadHeaderText = document.getElementById('upload-header-text');
        const uploadProgressToggle = document.getElementById('upload-progress-toggle');
        const uploadItemsContainer = document.getElementById('upload-items-container'); // Container per le singole progress bar
        // --- Fine Elementi Progress Box Upload ---

        // Mappa per tenere traccia degli elementi di upload individuali per ID
        const uploadItems = new Map(); // Map<uploadId, { element: HTMLElement, fileName: string, percentage: number, statusText: string, filePath: string }>

        // --- Elementi Modale Chunk Size ---
        const chunkSizeModal = document.getElementById('chunk-size-modal');
        const chunkSizeSlider = document.getElementById('chunk-size-slider');
        const chunkSizeDisplay = document.getElementById('chunk-size-display');
        // Nuovo slider per il parallelismo
        const parallelChunksSlider = document.getElementById('parallel-chunks-slider');
        const parallelChunksDisplay = document.getElementById('parallel-chunks-display');

        const startUploadBtn = document.getElementById('start-upload-btn');
        const cancelModalBtn = document.getElementById('cancel-modal-btn');
        // --- Fine Elementi Modale Chunk Size ---

        // Variabili per memorizzare i file selezionati e la dimensione chunk scelta
        let filesToUpload = [];
        let selectedChunkSize = 4194304; // Default 4MB
        let selectedParallelChunks = 4; // Default 4

        // --- Elementi Rotella di Caricamento Granulare (specifico per filelist) ---
        const filelistLoadingOverlay = document.getElementById('filelist-loading-overlay'); // Riferimento all'overlay specifico della lista file
        // --- Fine Elementi Rotella di Caricamento ---

        // --- Funzioni per controllare lo spinner della lista file (rese globali) ---
        window.showFilelistLoadingSpinner = function() { // Resa globale
             console.log('Index - showFilelistLoadingSpinner called.');
             if (filelistLoadingOverlay) {
                 filelistLoadingOverlay.style.display = 'flex'; // Mostra l'overlay
             }
        };

        window.hideFilelistLoadingSpinner = function() { // Resa globale
             console.log('Index - hideFilelistLoadingSpinner called.');
             if (filelistLoadingOverlay) {
                 filelistLoadingOverlay.style.display = 'none'; // Nasconde l'overlay
             }
        };
        // --- Fine Funzioni Rotella di Caricamento Granulare ---

        // --- Elementi Pulsante Nuova Cartella ---
        const createFolderBtn = document.getElementById('create-folder-btn');
        let currentSelectedStorageName = ''; // Variabile per memorizzare lo storage selezionato
        let currentSelectedDirPath = ''; // Variabile per memorizzare il percorso selezionato
        // --- Fine Elementi Pulsante Nuova Cartella ---

        // --- Elementi Nuova Modale Creazione Cartella ---
        const createFolderModal = document.getElementById('create-folder-modal');
        const newFolderNameInput = document.getElementById('new-folder-name');
        const cancelCreateFolderBtn = document.getElementById('cancel-create-folder-btn');
        const confirmCreateFolderBtn = document.getElementById('confirm-create-folder-btn');
        // --- Fine Elementi Nuova Modale Creazione Cartella ---

        // --- Elementi Nuova Modale Conferma Cancellazione ---
        const deleteConfirmModal = document.getElementById('delete-confirm-modal');
        const deleteItemNameElement = document.getElementById('delete-item-name');
        const deleteWarningMessageElement = document.getElementById('delete-warning-message'); // Nuovo elemento per il messaggio di avviso
        const cancelDeleteBtn = document.getElementById('cancel-delete-btn');
        const confirmDeleteBtn = document.getElementById('confirm-delete-btn');
        let itemToDelete = null; // Memorizza i dettagli dell'elemento da cancellare { storageName, itemPath, itemName }
        // --- Fine Elementi Nuova Modale Conferma Cancellazione ---


        // Funzione per formattare la dimensione del chunk per la visualizzazione
        function formatChunkSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(i === 0 ? 0 : 1)) + ' ' + sizes[i];
        }

        // Aggiorna il display del valore dello slider quando cambia
        chunkSizeSlider.addEventListener('input', (event) => {
            chunkSizeDisplay.textContent = formatChunkSize(parseInt(event.target.value, 10));
        });
        // Aggiorna il display del valore dello slider parallel chunks quando cambia
        parallelChunksSlider.addEventListener('input', (event) => {
            parallelChunksDisplay.textContent = parseInt(event.target.value, 10);
        });
        // Funzione per mostrare la modale chunk size
        function showChunkSizeModal(maxSize) {
            console.log('Index - showChunkSizeModal called with maxSize:', maxSize);
            chunkSizeSlider.max = maxSize; // Imposta il valore massimo dello slider
            chunkSizeSlider.value = Math.min(selectedChunkSize, maxSize); // Imposta il valore corrente (o max se default > max)
            chunkSizeDisplay.textContent = formatChunkSize(parseInt(chunkSizeSlider.value, 10)); // Aggiorna il display iniziale

            // Inizializza anche lo slider per il parallelismo
            parallelChunksSlider.value = selectedParallelChunks;
            parallelChunksDisplay.textContent = selectedParallelChunks;

            chunkSizeModal.style.display = 'flex'; // Mostra la modale
        }

        // Funzione per nascondere la modale chunk size
        function hideChunkSizeModal() {
            console.log('Index - hideChunkSizeModal called.');
            chunkSizeModal.style.display = 'none'; // Nasconde la modale
        }

        // Listener per il pulsante "Avvia Upload" nella modale
        startUploadBtn.addEventListener('click', () => {
            selectedChunkSize = parseInt(chunkSizeSlider.value, 10); // Salva la dimensione chunk scelta
            selectedParallelChunks = parseInt(parallelChunksSlider.value, 10); // Salva il numero di chunk paralleli
            hideChunkSizeModal(); // Nasconde la modale
            // Notifica l'iframe filelist di avviare l'upload con i file e la dimensione chunk scelti
            const filelistIframe = document.getElementById('filelist-iframe');
            if (filelistIframe && filelistIframe.contentWindow) {
                console.log('Index - Sending start_upload_process message to filelist iframe.');
                filelistIframe.contentWindow.postMessage({
                    type: 'start_upload_process',
                    payload: {
                        files: filesToUpload, // Passa la lista dei file selezionati
                        chunkSize: selectedChunkSize,
                        parallelChunks: selectedParallelChunks // Passa il numero di chunk paralleli
                    }
                }, '*');
            }
            filesToUpload = []; // Pulisce la lista dei file in attesa
        });
        // Listener per il pulsante "Annulla" nella modale chunk size
        cancelModalBtn.addEventListener('click', () => {
            hideChunkSizeModal(); // Nasconde la modale
            filesToUpload = []; // Pulisce la lista dei file in attesa (annulla la selezione)
            console.log('Index - Chunk size selection cancelled by user.');
        });
        // Opzionale: chiudi la modale chunk size cliccando fuori dal contenuto
        chunkSizeModal.addEventListener('click', (event) => {
            if (event.target === chunkSizeModal) {
                // hideChunkSizeModal(); // Decide if clicking overlay should cancel
                // filesToUpload = []; // Clear files on overlay click cancel
            }
        });


        // Funzione per aggiungere un messaggio alla cronologia
        function addMessageToHistory(message, type = 'info') { // type can be 'info', 'warning', 'error', etc. for future styling
            const li = document.createElement('li');
            const timestampSpan = document.createElement('span');
            timestampSpan.classList.add('message-timestamp');
            timestampSpan.textContent = new Date().toLocaleTimeString(); // Aggiunge l'ora corrente

            li.appendChild(timestampSpan);
            li.appendChild(document.createTextNode(message)); // Aggiunge il testo del messaggio

            // Aggiunge il nuovo messaggio all'inizio della lista (i più recenti in alto)
            messageList.prepend(li);
            // Opzionale: limita il numero di messaggi nella cronologia
            const maxMessages = 50; // Limite massimo di messaggi
            while (messageList.children.length > maxMessages) {
                messageList.removeChild(messageList.lastChild);
            }
        }

        // Funzione per mostrare un messaggio nell'area messaggi (solo l'ultimo visibile quando compressa)
        // Ora questa funzione aggiunge semplicemente alla cronologia e la mostra se nascosta
        function showMessage(message) {
             addMessageToHistory(message);
             // Assicura che l'area messaggi sia visibile (potrebbe essere nascosta da hideMessage)
             messageHistoryArea.style.display = 'flex';
             // Se l'area è compressa, aggiorna l'header con l'ultimo messaggio (opzionale, richiede logica aggiuntiva)
             // Per ora, l'header mostra solo il titolo "Cronologia Messaggi"
        }

        // Funzione per nascondere l'area messaggi (se vuota o su richiesta esplicita)
        function hideMessageHistory() {
             messageHistoryArea.style.display = 'none';
        }

        // Funzione per espandere/comprimere l'area cronologia messaggi
        function toggleMessageHistory() {
            messageHistoryArea.classList.toggle('expanded');
            if (messageHistoryArea.classList.contains('expanded')) {
                messageHistoryToggle.textContent = '▼'; // Icona giù
            } else {
                messageHistoryToggle.textContent = '▲'; // Icona su
            }
        }

        // Aggiungi listener per espandere/comprimere l'area messaggi
        messageHistoryHeader.addEventListener('click', toggleMessageHistory);
        // handleBackendMessage è definita in websocket.js e chiamata da lì quando arriva un messaggio.
        // Qui la sovrascriviamo per delegare i messaggi agli iframe e registrarli nella cronologia.
        // È importante che window.handleBackendMessage sia definita *PRIMA* dell'inclusione di websocket.js
        // per sovrascrivere qualsiasi definizione placeholder in websocket.js.
        // *** Definizione di window.handleBackendMessage spostata qui, PRIMA dell'inclusione di websocket.js ***
        window.handleBackendMessage = (message) => {
            console.log('Index - Backend message received:', message); // Log mantenuto per debug
            // Aggiunge il messaggio alla cronologia
            addMessageToHistory(`Backend: ${JSON.stringify(message)}`);
            const treeviewIframe = document.getElementById('treeview-iframe');
            const filelistIframe = document.getElementById('filelist-iframe');

            // Invia il messaggio all'iframe treeview
            if (treeviewIframe && treeviewIframe.contentWindow && treeviewIframe.contentWindow.handleBackendMessage) {
                 treeviewIframe.contentWindow.handleBackendMessage(message);
            }

            // Invia il messaggio all'iframe filelist
            if (filelistIframe && filelistIframe.contentWindow && filelistIframe.contentWindow.handleBackendMessage) {
                 filelistIframe.contentWindow.handleBackendMessage(message);
            }

            // La gestione dei messaggi specifici (come 'pong') avviene ora solo in websocket.js
            // che chiamerà questa funzione per la gestione generica e poi la sua logica specifica.
        };


        // Function called by treeview iframe when an item is selected
        // Now accepts storageName and storageType as parameters
        function handleTreeviewSelect(storageName, itemPath, storageType) {
            console.log("Index - Item selected in treeview:", storageName, itemPath, storageType);
            // Logga l'azione nella cronologia
            addMessageToHistory(`Navigato a: ${storageName}/${itemPath}`);
            // Memorizza lo storage e il percorso selezionati
            currentSelectedStorageName = storageName;
            currentSelectedDirPath = itemPath;

            // Mostra o nasconde il pulsante "Nuova Cartella" in base al tipo di storage
            if (storageType === 'local' || storageType === 'azure-blob') {
                createFolderBtn.style.display = 'inline-block'; // Mostra il pulsante
                 // Abilita il pulsante solo se è selezionata una directory (non un file, anche se treeview mostra solo dir)
                 // Per ora, lo abilitiamo sempre se è uno storage supportato
                 createFolderBtn.disabled = false;
            } else {
                createFolderBtn.style.display = 'none'; // Nasconde il pulsante per altri tipi di storage
            }


            const filelistIframe = document.getElementById('filelist-iframe');
            if (filelistIframe && filelistIframe.contentWindow) {
                // Send a message to the filelist iframe to load the file list
                // Pass storageName and itemPath
                filelistIframe.contentWindow.postMessage({
                    type: 'load_filelist',
                    payload: { storageName: storageName, dirPath: itemPath }
                }, '*'); // Use '*' as targetOrigin for simplicity, specify origin in production
            }
        }

        // --- Funzioni per la Progress Box Upload ---

        // Funzione per espandere/comprimere la progress box upload
        function toggleUploadProgressBox() {
            console.log('Index - toggleUploadProgressBox called.');
            // Controlla se la box non è in uno stato finale (completato, fallito, annullato)
            if (!uploadProgressBox.classList.contains('upload-final-state')) {
                uploadProgressBox.classList.toggle('expanded');
                if (uploadProgressBox.classList.contains('expanded')) {
                    uploadProgressToggle.textContent = '▼'; // Icona giù
                    uploadHeaderText.textContent = 'Upload in corso...';
                } else {
                    uploadProgressToggle.textContent = '▲'; // Icona su
                    uploadHeaderText.textContent = 'Upload'; // Titolo iconizzato
                }
            } else {
                 // Se è in stato finale, il click sull'header/toggle chiude la box
                 hideUploadProgressBox();
            }
        }

        // Funzione per mostrare la progress box completa
        function showUploadProgressBox() {
            console.log('Index - showUploadProgressBox called.');
            uploadProgressBox.style.display = 'block';
             // Assicura che sia espansa quando mostrata per la prima volta
             if (!uploadProgressBox.classList.contains('expanded')) {
                 uploadProgressBox.classList.add('expanded');
                 uploadProgressToggle.textContent = '▼'; // Icona giù
             }
             uploadHeaderText.textContent = 'Upload in corso...';
             // Assicura che i listener per espandere/comprimere siano attivi (non quelli per nascondere)
             uploadProgressHeader.removeEventListener('click', hideUploadProgressBox);
             uploadProgressToggle.removeEventListener('click', hideUploadProgressBox);
             uploadProgressHeader.addEventListener('click', toggleUploadProgressBox);
             uploadProgressToggle.addEventListener('click', toggleUploadProgressBox);
        }

        // Funzione per nascondere la progress box completa
        function hideUploadProgressBox() {
            console.log('Index - hideUploadProgressBox called.');
            uploadProgressBox.style.display = 'none';
             // Opzionale: pulire gli elementi upload completati/falliti quando la box viene nascosta
             uploadItemsContainer.innerHTML = '';
             uploadItems.clear(); // Pulisce la mappa degli upload
             uploadProgressBox.classList.remove('expanded'); // Resetta lo stato espanso
             uploadProgressBox.classList.remove('upload-final-state'); // Rimuove lo stato finale
             uploadHeaderText.textContent = 'Upload'; // Resetta il testo header
             uploadProgressToggle.textContent = '▲'; // Resetta icona
             // Rimuove i listener specifici per lo stato finale
             uploadProgressHeader.removeEventListener('click', hideUploadProgressBox);
             uploadProgressToggle.removeEventListener('click', hideUploadProgressBox);
             // Aggiunge nuovamente i listener per espandere/comprimere
             uploadProgressHeader.addEventListener('click', toggleUploadProgressBox);
             uploadProgressToggle.addEventListener('click', toggleUploadProgressBox);
        }

        // Funzione per aggiornare o creare un elemento di progresso per un upload specifico
        // Aggiunto parametro filePath per il tooltip
        function updateUploadProgress(uploadId, fileName, percentage, statusText, filePath, isFinal = false, statusClass = '') {
            console.log(`Index - updateUploadProgress called for ID ${uploadId}: ${percentage.toFixed(2)}% - ${statusText}`);
            let uploadItemElement = uploadItems.has(uploadId) ? uploadItems.get(uploadId).element : null;

            if (!uploadItemElement) {
                console.log(`Index - Creating new upload item element for ID ${uploadId}`);
                // Crea un nuovo elemento se non esiste
                uploadItemElement = document.createElement('div');
                uploadItemElement.classList.add('upload-item');
                uploadItemElement.dataset.uploadId = uploadId; // Memorizza l'ID upload

                uploadItemElement.innerHTML = `
                    <div class="upload-item-header">
                        <div class="upload-file-name"></div>
                        <button class="upload-cancel-button">✕</button>
                    </div>
                    <div class="upload-progress-bar-container" title="">
                        <div class="upload-progress-bar">0%</div>
                    </div>
                    <div class="upload-status-text"></div>
                `;
                uploadItemsContainer.appendChild(uploadItemElement);
                // Memorizza filePath nella mappa per poterlo recuperare per il tooltip
                uploadItems.set(uploadId, { element: uploadItemElement, fileName: fileName, percentage: 0, statusText: '', filePath: filePath });
                // Aggiungi listener al pulsante di annullamento
                uploadItemElement.querySelector('.upload-cancel-button').addEventListener('click', () => {
                    if (confirm(`Sei sicuro di voler annullare l'upload di "${fileName}"?`)) {
                         // Invia un messaggio all'iframe filelist per annullare l'upload specifico
                         const filelistIframe = document.getElementById('filelist-iframe');
                         if (filelistIframe && filelistIframe.contentWindow) {
                             console.log(`Index - Sending cancel_upload_request for ID ${uploadId}`);
                             filelistIframe.contentWindow.postMessage({
                                 type: 'cancel_upload_request',
                                 payload: { uploadId: uploadId } // Passa l'ID upload da annullare
                             }, '*');
                         }
                    }
                });
            }

            // Aggiorna i dettagli dell'elemento
            const fileN = uploadItemElement.querySelector('.upload-file-name');
            const progressBarContainer = uploadItemElement.querySelector('.upload-progress-bar-container'); // Seleziona il container
            const progressBar = uploadItemElement.querySelector('.upload-progress-bar');
            const statusTextElem = uploadItemElement.querySelector('.upload-status-text');
            const cancelButton = uploadItemElement.querySelector('.upload-cancel-button');

            fileN.textContent = fileName;
            progressBar.style.width = percentage + '%';
            progressBar.textContent = percentage.toFixed(0) + '%';
            statusTextElem.textContent = statusText;

            // Aggiorna il tooltip con il percorso completo
            progressBarContainer.title = filePath;
            // Aggiorna lo stato nella mappa
            uploadItems.get(uploadId).percentage = percentage;
            uploadItems.get(uploadId).statusText = statusText;
            uploadItems.get(uploadId).filePath = filePath; // Assicura che il percorso sia aggiornato


            // Gestisce lo stato finale (completato, fallito, annullato)
            if (isFinal) {
                 uploadItemElement.classList.add('upload-final-state', statusClass);
                 cancelButton.style.display = 'none'; // Nasconde il pulsante annulla
                 // Aggiorna l'header se tutti gli upload sono in stato finale
                 checkOverallUploadStatus();
            } else {
                 // Rimuove le classi di stato finale se l'upload riprende o cambia stato
                 uploadItemElement.classList.remove('upload-final-state', 'complete', 'failed', 'cancelled');
                 cancelButton.style.display = 'block'; // Mostra il pulsante annulla
                 // Aggiorna l'header se c'è almeno un upload non in stato finale
                 checkOverallUploadStatus();
            }

            // Mostra la progress box se non è già visibile
            showUploadProgressBox();
        }

        // Funzione per verificare lo stato complessivo degli upload e aggiornare l'header
        function checkOverallUploadStatus() {
             console.log('Index - checkOverallUploadStatus called. Total upload items:', uploadItems.size);
             let allFinal = true;
             let anyFailed = false;
             let anyInProgress = false;

             if (uploadItems.size === 0) {
                 // Se non ci sono upload, nascondi la box
                 hideUploadProgressBox();
                 return;
             }

             uploadItems.forEach(item => {
                 if (!item.element.classList.contains('upload-final-state')) {
                     allFinal = false;
                     anyInProgress = true;
                 }
                 if (item.element.classList.contains('failed')) {
                     anyFailed = true;
                 }
             });
             if (allFinal) {
                 console.log('Index - All uploads are in final state.');
                 uploadProgressBox.classList.add('upload-final-state');
                 uploadProgressToggle.textContent = '✕'; // Icona X per chiudere
                 // Rimuove listener precedente e aggiunge listener per nascondere
                 uploadProgressHeader.removeEventListener('click', toggleUploadProgressBox);
                 uploadProgressToggle.removeEventListener('click', toggleUploadProgressBox); // Corretto: usa toggleUploadProgressBox qui
                 uploadProgressHeader.addEventListener('click', hideUploadProgressBox);
                 uploadProgressToggle.addEventListener('click', hideUploadProgressBox);

                 if (anyFailed) {
                     uploadHeaderText.textContent = 'Upload(s) Fallito/i';
                 } else {
                     uploadHeaderText.textContent = 'Upload(s) Completato/i';
                 }
             } else {
                 console.log('Index - Some uploads are still in progress.');
                 uploadProgressBox.classList.remove('upload-final-state');
                 uploadProgressToggle.textContent = '▼'; // Icona giù
                 // Assicura che i listener per espandere/comprimere siano attivi
                 uploadProgressHeader.removeEventListener('click', hideUploadProgressBox);
                 uploadProgressToggle.removeEventListener('click', hideUploadProgressBox);
                 uploadProgressHeader.addEventListener('click', toggleUploadProgressBox);
                 uploadProgressToggle.addEventListener('click', toggleUploadProgressBox);

                 if (anyInProgress) {
                     uploadHeaderText.textContent = 'Upload in corso...';
                 } else {
                      // Questo caso non dovrebbe verificarsi se allFinal è false ma nessun upload è in corso
                      // Potrebbe indicare uno stato intermedio o un bug
                      uploadHeaderText.textContent = 'Upload(s) in attesa...';
                 }
             }
        }


        // Aggiungi listener alla header della progress box per espandere/comprimere
        // Spostati qui *dopo* la definizione della funzione toggleUploadProgressBox
        uploadProgressHeader.addEventListener('click', toggleUploadProgressBox);
        uploadProgressToggle.addEventListener('click', toggleUploadProgressBox);


        // --- Funzioni Rotella di Caricamento Generale (ora non usate per filelist) ---
        // Queste funzioni potrebbero essere rimosse o riadattate se non ci sono più spinner globali
        // o per bloccare l'interfaccia durante operazioni che non sono legate a un pannello specifico.
        function showLoadingSpinner() {
             console.log('Index - showLoadingSpinner called (global).');
             // Se hai ancora uno spinner globale, abilitalo qui.
             // loadingOverlay.style.display = 'flex';
             // document.getElementById('left-panel').style.pointerEvents = 'none';
             // document.getElementById('main-panel').style.pointerEvents = 'none';
        }

        function hideLoadingSpinner() {
             console.log('Index - hideLoadingSpinner called (global).');
             // Se hai ancora uno spinner globale, disabilitalo qui.
             // loadingOverlay.style.display = 'none';
             // document.getElementById('left-panel').style.pointerEvents = 'auto';
             // document.getElementById('main-panel').style.pointerEvents = 'auto';
        }
        // --- Fine Funzioni Rotella di Caricamento Generale ---


        // --- Funzioni Pulsante Nuova Cartella ---
        createFolderBtn.addEventListener('click', () => {
            console.log('Index - Create Folder button clicked.');
            // Mostra la modale per la creazione della cartella
            showCreateFolderModal();
        });
        // --- Fine Funzioni Pulsante Nuova Cartella ---

        // --- Funzioni Nuova Modale Creazione Cartella ---
        function showCreateFolderModal() {
            console.log('Index - showCreateFolderModal called.');
            newFolderNameInput.value = ''; // Pulisce il campo input
            createFolderModal.style.display = 'flex'; // Mostra la modale
            newFolderNameInput.focus(); // Imposta il focus sul campo input
        }

        function hideCreateFolderModal() {
            console.log('Index - hideCreateFolderModal called.');
            createFolderModal.style.display = 'none'; // Nasconde la modale
        }

        // Listener per il pulsante "Crea" nella modale creazione cartella
        confirmCreateFolderBtn.addEventListener('click', () => {
            const folderName = newFolderNameInput.value.trim();
            if (folderName) {
                hideCreateFolderModal(); // Nasconde la modale
                // Invia un messaggio all'iframe filelist con il nome della cartella e il contesto corrente
                const filelistIframe = document.getElementById('filelist-iframe');
                if (filelistIframe && filelistIframe.contentWindow) {
                    console.log(`Index - Sending create_directory_confirmed message to filelist iframe for folder "${folderName}".`);
                    filelistIframe.contentWindow.postMessage({
                        type: 'create_directory_confirmed',
                        payload: {
                            storageName: currentSelectedStorageName,
                            dirPath: currentSelectedDirPath,
                            folderName: folderName
                        }
                    }, '*');
                }
            } else {
                window.showToast('Il nome della cartella non può essere vuoto.', 'warning');
            }
        });
        // Listener per il pulsante "Annulla" nella modale creazione cartella
        cancelCreateFolderBtn.addEventListener('click', () => {
            hideCreateFolderModal(); // Nasconde la modale
            console.log('Index - Create folder cancelled by user.');
             // Notifica l'iframe filelist che l'operazione è stata annullata (opzionale)
             const filelistIframe = document.getElementById('filelist-iframe');
             if (filelistIframe && filelistIframe.contentWindow) {
                 filelistIframe.contentWindow.postMessage({
                     type: 'modal_cancelled',
                     payload: { operation: 'create_directory' }
                 }, '*');
             }
        });
        // Chiudi la modale creazione cartella cliccando fuori dal contenuto (opzionale)
        createFolderModal.addEventListener('click', (event) => {
            if (event.target === createFolderModal) {
                 // hideCreateFolderModal(); // Decide if clicking overlay should cancel
                 // console.log('Index - Create folder cancelled by clicking overlay.');
                 // // Notifica l'iframe filelist che l'operazione è stata annullata (opzionale)
                 // const filelistIframe = document.getElementById('filelist-iframe');
                 // if (filelistIframe && filelistIframe.contentWindow) {
                 //     filelistIframe.contentWindow.postMessage({
                 //         type: 'modal_cancelled',
                 //         payload: { operation: 'create_directory' }
                 //     }, '*');
                 // }
            }
        });
        // --- Fine Funzioni Nuova Modale Creazione Cartella ---

        // --- Funzioni Nuova Modale Conferma Cancellazione ---
        function showDeleteConfirmModal(itemDetails) {
            console.log('Index - showDeleteConfirmModal called with item:', itemDetails);
            itemToDelete = itemDetails; // Memorizza i dettagli dell'elemento da cancellare
            deleteItemNameElement.textContent = `Elemento: "${itemDetails.itemName}"`; // Imposta il nome dell'elemento nella modale
            // Imposta il messaggio di avviso personalizzato o quello di default
            deleteWarningMessageElement.textContent = itemDetails.warningMessage || "Sei sicuro di voler eliminare questo elemento? Questa azione non può essere annullata.";
            deleteConfirmModal.style.display = 'flex'; // Mostra la modale
        }

        function hideDeleteConfirmModal() {
            console.log('Index - hideDeleteConfirmModal called.');
            deleteConfirmModal.style.display = 'none'; // Nasconde la modale
            itemToDelete = null; // Pulisce i dettagli memorizzati
        }

        // Listener per il pulsante "Elimina" nella modale conferma cancellazione
        confirmDeleteBtn.addEventListener('click', () => {
            // Store item details locally before hiding the modal
            const detailsToProcess = itemToDelete;

            if (detailsToProcess) {
                hideDeleteConfirmModal(); // Nasconde la modale

                // Invia un messaggio all'iframe filelist per confermare la cancellazione
                const filelistIframe = document.getElementById('filelist-iframe');
                if (filelistIframe && filelistIframe.contentWindow) {
                    console.log(`Index - Sending delete_item_confirmed message to filelist iframe for item "${detailsToProcess.itemName}".`);
                    filelistIframe.contentWindow.postMessage({
                        type: 'delete_item_confirmed',
                        payload: {
                            storageName: detailsToProcess.storageName,
                            itemPath: detailsToProcess.itemPath,
                            itemName: detailsToProcess.itemName
                        }
                    }, '*');
                }
            } else {
                console.error("Index - confirmDeleteBtn clicked but itemToDelete is null.");
                // Optionally hide modal or show error if somehow it was null
                hideDeleteConfirmModal();
            }
        });

        // Listener per il pulsante "Annulla" nella modale conferma cancellazione
        cancelDeleteBtn.addEventListener('click', () => {
            hideDeleteConfirmModal(); // Nasconde la modale
            console.log('Index - Delete cancelled by user.');
             // Notifica l'iframe filelist che l'operazione è stata annullata (opzionale)
             const filelistIframe = document.getElementById('filelist-iframe');
             if (filelistIframe && filelistIframe.contentWindow) {
                 filelistIframe.contentWindow.postMessage({
                     type: 'modal_cancelled',
                     payload: { operation: 'delete_item' }
                 }, '*');
             }
        });
        // Chiudi la modale conferma cancellazione cliccando fuori dal contenuto (opzionale)
        deleteConfirmModal.addEventListener('click', (event) => {
            if (event.target === deleteConfirmModal) {
                 // hideDeleteConfirmModal(); // Decide if clicking overlay should cancel
                 // console.log('Index - Delete cancelled by clicking overlay.');
                 // // Notifica l'iframe filelist che l'operazione è stata annullata (opzionale)
                 // const filelistIframe = document.getElementById('filelist-iframe');
                 // if (filelistIframe && filelistIframe.contentWindow) {
                 //     filelistIframe.contentWindow.postMessage({
                 //         type: 'modal_cancelled',
                 //         payload: { operation: 'delete_item' }
                 //     }, '*');
                 // }
            }
        });
        // --- Fine Funzioni Nuova Modale Conferma Cancellazione ---


        // Add a listener for messages posted by iframes (for more robust communication)
        window.addEventListener('message', event => {
            // In production, verify the event origin for security: event.origin
            console.log('Index - Message received from iframe:', event.data); // Log ricezione messaggio
            // Handle specific messages from iframes, such as connection status updates
            if (event.data && event.data.type === 'connection_status') {
                if (event.data.payload.status === 'lp_fallback') {
                    showMessage('Warning: Connessione WebSocket non disponibile. Utilizzo Long Polling.');
                } else if (event.data.payload.status === 'ws_established') {
                    addMessageToHistory('Connessione WebSocket stabilita.');
                    // hideMessage(); // Non nascondere più l'area messaggi, aggiungi alla cronologia
                } else if (event.data.payload.status === 'ws_connecting') {
                     addMessageToHistory('Tentativo di riconnessione WebSocket...');
                } else if (event.data.payload.status === 'ws_error') {
                     showMessage('Warning: Errore di connessione WebSocket. Tentativo Long Polling.');
                }
            }
             // Handle specific messages from iframes if needed
             // Example: if an iframe needs to send a message to the backend via sendMessage
             if (event.data && event.data.type === 'send_message_to_backend') {
                 // L'iframe invia il payload del messaggio, che viene poi passato a window.sendMessage
                 if (window.sendMessage) { // Make sure sendMessage is available
                     window.sendMessage(event.data.payload);
                 } else {
                     console.error('Index - sendMessage not available to send message to backend.');
                 }
             }

             // --- Handle Upload Progress Messages from filelist-iframe ---
            if (event.data && event.data.type === 'upload_progress') {
                 const payload = event.data.payload;
                 // Passa filePath a updateUploadProgress
                 updateUploadProgress(payload.uploadId, payload.fileName, payload.percentage, payload.statusText, payload.filePath);
            }

             if (event.data && event.data.type === 'upload_complete') {
                 const payload = event.data.payload;
                 // Passa filePath a updateUploadProgress
                 updateUploadProgress(payload.uploadId, payload.fileName, 100, 'Completato!', payload.filePath, true, 'complete'); // Imposta stato finale e classe
                 addMessageToHistory(`Upload completato: ${payload.fileName}`); // Logga nella cronologia
                 checkOverallUploadStatus(); // Ricontrolla lo stato complessivo
             }

              if (event.data && event.data.type === 'upload_failed') {
                 const payload = event.data.payload;
                 // Passa filePath a updateUploadProgress
                 updateUploadProgress(payload.uploadId, payload.fileName, payload.percentage || 0, 'Errore: ' + payload.error, payload.filePath, true, 'failed'); // Imposta stato finale e classe
                 addMessageToHistory(`Upload fallito: ${payload.fileName} - ${payload.error}`, 'error'); // Logga nella cronologia
                 checkOverallUploadStatus(); // Ricontrolla lo stato complessivo
              }

              if (event.data && event.data.type === 'upload_cancelled') {
                 const payload = event.data.payload;
                 // Passa filePath a updateUploadProgress
                 updateUploadProgress(payload.uploadId, payload.fileName, payload.percentage || 0, 'Annullato.', payload.filePath, true, 'cancelled'); // Imposta stato finale e classe
                 addMessageToHistory(`Upload annullato: ${payload.fileName}`, 'warning'); // Logga nella cronologia
                 checkOverallUploadStatus(); // Ricontrolla lo stato complessivo
              }

             // --- End Handle Upload Progress Messages ---

              // --- Handle File/Directory Operations Messages from filelist-iframe ---
             if (event.data && event.data.type === 'file_operation_status') {
                 const payload = event.data.payload;
                 let message = `Operazione file: ${payload.operation} su ${payload.itemPath}`;
                 if (payload.status === 'success') {
                     message += ' completata con successo.';
                 } else if (payload.status === 'error') {
                     message += ` fallita. Errore: ${payload.error}`;
                 } else { // 'info' status
                     message += ` in corso...`;
                 }
                 addMessageToHistory(message, payload.status === 'error' ? 'error' : (payload.status === 'warning' ? 'warning' : 'info'));
             }
              // --- End Handle File/Directory Operations Messages ---

              // --- Handle Upload File Selection Message from filelist-iframe ---
             if (event.data && event.data.type === 'show_chunk_size_modal') {
                 console.log('Index - Received show_chunk_size_modal message.');
                 filesToUpload = event.data.payload.files; // Store the selected files
                 const firstFileSize = filesToUpload.length > 0 ? filesToUpload[0].size : 1; // Use size of the first file, min 1
                 showChunkSizeModal(firstFileSize); // Show the modal
             }
             // --- End Handle Upload File Selection Message ---

             // --- Handle Loading Spinner Messages from filelist-iframe ---
             if (event.data && event.data.type === 'show_loading_spinner') {
                 // Chiama la funzione specifica per lo spinner della lista file
                 window.showFilelistLoadingSpinner(); // Chiamata globale
             }
             if (event.data && event.data.type === 'hide_loading_spinner') {
                 // Chiama la funzione specifica per nascondere lo spinner della lista file
                 window.hideFilelistLoadingSpinner(); // Chiamata globale
             }
             // --- End Handle Loading Spinner Messages ---

             // --- Handle Modal Trigger Messages from filelist-iframe ---
             if (event.data && event.data.type === 'show_create_folder_modal') {
                 // Payload should contain storageName and dirPath (already stored in currentSelected variables)
                 showCreateFolderModal();
             }
             if (event.data && event.data.type === 'show_delete_item_modal') {
                 // Payload should contain item details: { storageName, itemPath, itemName }
                 // Aggiunto il parametro warningMessage
                 showDeleteConfirmModal(event.data.payload);
             }
             // --- End Handle Modal Trigger Messages ---


        });
        // Aggiungi listener alla header della progress box per espandere/comprimere
        // Spostati qui *dopo* la definizione della funzione toggleUploadProgressBox
        uploadProgressHeader.addEventListener('click', toggleUploadProgressBox);
        uploadProgressToggle.addEventListener('click', toggleUploadProgressBox);


        // Start WebSocket connection on main page load
        // connectWebSocket is defined in websocket.js and called from here
        window.addEventListener('load', () => {
             console.log('Index - Main page loaded, starting WebSocket connection.');
             addMessageToHistory('Pagina caricata, avvio connessione...'); // Logga l'avvio
             if (window.connectWebSocket) {
                 window.connectWebSocket();
             } else {
                 console.error('Index - connectWebSocket not available on startup.');
                 addMessageToHistory('Errore: Funzione di connessione non disponibile.', 'error');
             }
        });
    </script>
    <script src="/js/notifications.js"></script>
    <script src="/js/websocket.js"></script>
</body>
</html>