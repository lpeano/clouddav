--- a/static/js/treeview_controller.js
+++ b/static/js/treeview_controller.js
@@ -135,7 +135,8 @@
                         page: 1,
                         items_per_page: 1000, // Un numero grande per ottenere tutte le sottodirectory
                         name_filter: '',
-                        timestamp_filter: ''
+                        timestamp_filter: '',
+                        only_directories: true // NUOVO PARAMETRO
                     }
                 });
                 lastRequestIds.set(pathKey, requestID);
@@ -157,28 +158,26 @@
         const storageName = directoryElement.dataset.storageName;
         const storageType = directoryElement.dataset.storageType;
 
-        items.sort((a, b) => {
-            if (a.is_dir === b.is_dir) return a.name.localeCompare(b.name);
-            return a.is_dir ? -1 : 1; // Directory prima dei file
-        });
+        // Ordina solo per nome, dato che tutti gli items dovrebbero essere directory
+        items.sort((a, b) => a.name.localeCompare(b.name));
 
         items.forEach(item => {
-            // *** MODIFICA CHIAVE: Rimossa la condizione if (!item.is_dir) return; ***
-            // Ora processiamo sia file che directory
+            // Se il backend invia solo directory, item.is_dir dovrebbe essere sempre true.
+            // Aggiungiamo un controllo per sicurezza o se il backend potesse inviare misto in altri scenari.
+            if (!item.is_dir) { // Non dovrebbe accadere se only_directories:true funziona
+                console.warn(`TreeviewCtrl: Ricevuto un file (${item.name}) quando ci si aspettavano solo directory.`);
+                return;
+            }
 
             const li = document.createElement('li');
             li.textContent = item.name;
             li.dataset.storageName = storageName;
             li.dataset.path = item.path;
-            li.dataset.storageType = storageType;
+            li.dataset.storageType = storageType; // Potrebbe non essere più necessario se solo dir
             
-            li.addEventListener('click', handleTreeviewItemClick);
-
-            if (item.is_dir) {
-                li.classList.add('directory');
-                const childUl = document.createElement('ul'); // Aggiungi ul solo per le directory
-                li.appendChild(childUl);
-            } else {
-                li.classList.add('file'); // Aggiungi classe 'file' per lo styling (es. icona)
-                // I file non hanno un 'ul' figlio e non si espandono/comprimono
-            }
+            li.classList.add('directory'); // Tutti gli item sono directory
+            const childUl = document.createElement('ul');
+            li.appendChild(childUl);
+            
+            li.addEventListener('click', handleTreeviewItemClick);
             ul.appendChild(li);
         });
     }
--- a/storage/azureblob/azureblob.go
+++ b/storage/azureblob/azureblob.go
@@ -62,7 +62,7 @@
 }
 
 // ListItems lists blobs and virtual directories in a given path (prefix).
-func (p *AzureBlobStorageProvider) ListItems(ctx context.Context, claims *auth.UserClaims, path string, page int, itemsPerPage int, nameFilter string, timestampFilter *time.Time) (*storage.ListItemsResponse, error) {
+func (p *AzureBlobStorageProvider) ListItems(ctx context.Context, claims *auth.UserClaims, path string, page int, itemsPerPage int, nameFilter string, timestampFilter *time.Time, onlyDirectories bool) (*storage.ListItemsResponse, error) {
 	userIdent := "unauthenticated"
 	if claims != nil {
 		userIdent = claims.Email
@@ -132,30 +132,31 @@
 				}
 			}
 
-			if pageResponse.Segment.BlobItems != nil {
-				for _, blobItem := range pageResponse.Segment.BlobItems {
-					name := strings.TrimPrefix(*blobItem.Name, prefix)
-					if strings.Contains(name, "/") {
-						continue
-					}
-
-					itemInfo := storage.ItemInfo{
-						Name:    name,
-						IsDir:   false,
-						Size:    *blobItem.Properties.ContentLength,
-						ModTime: *blobItem.Properties.LastModified,
-						Path:    *blobItem.Name,
-					}
-					if nameFilter != "" {
-						matched, _ := regexp.MatchString(nameFilter, itemInfo.Name)
-						if !matched {
+			if !onlyDirectories { // Processa i BlobItems solo se non vogliamo solo directory
+				if pageResponse.Segment.BlobItems != nil {
+					for _, blobItem := range pageResponse.Segment.BlobItems {
+						name := strings.TrimPrefix(*blobItem.Name, prefix)
+						if strings.Contains(name, "/") { // Ignora gli item che sono in "sottocartelle" rispetto al prefix corrente
 							continue
 						}
-					}
-					// Applica timestamp filter solo ai file
-					if timestampFilter != nil {
-						if !itemInfo.ModTime.After(*timestampFilter) {
+
+						itemInfo := storage.ItemInfo{
+							Name:    name,
+							IsDir:   false,
+							Size:    *blobItem.Properties.ContentLength,
+							ModTime: *blobItem.Properties.LastModified,
+							Path:    *blobItem.Name,
+						}
+						if nameFilter != "" {
+							matched, _ := regexp.MatchString(nameFilter, itemInfo.Name)
+							if !matched {
+								continue
+							}
+						}
+						// Applica timestamp filter solo ai file
+						if timestampFilter != nil {
+							if !itemInfo.ModTime.After(*timestampFilter) {
+								continue
+							}
 						}
+
+						allFilteredItems = append(allFilteredItems, itemInfo)
+						itemsCount++
 					}
-
-					allFilteredItems = append(allFilteredItems, itemInfo)
-					itemsCount++
 				}
 			}
 		}
@@ -163,9 +164,11 @@
 	}
 
 	sort.SliceStable(allFilteredItems, func(i, j int) bool {
+		// Se onlyDirectories è true, tutti gli elementi sono directory, quindi il primo check IsDir non è strettamente necessario
+		// ma lo lasciamo per coerenza se il flag non fosse rispettato perfettamente a monte.
 		if allFilteredItems[i].IsDir != allFilteredItems[j].IsDir {
-			return allFilteredItems[i].IsDir
+			return allFilteredItems[i].IsDir // Directory prima
 		}
-		return allFilteredItems[i].Name < allFilteredItems[j].Name
+		return allFilteredItems[i].Name < allFilteredItems[j].Name // Poi ordina per nome
 	})
 
 	totalItems := len(allFilteredItems)
--- a/storage/local/local.go
+++ b/storage/local/local.go
@@ -55,7 +55,7 @@
 
 // ListItems lists the contents of a specified directory, applying pagination and filters.
 // The path is relative to the configured storage root. Includes claims parameter for logging.
-func (p *LocalFilesystemProvider) ListItems(ctx context.Context, claims *auth.UserClaims, path string, page int, itemsPerPage int, nameFilter string, timestampFilter *time.Time) (*storage.ListItemsResponse, error) {
+func (p *LocalFilesystemProvider) ListItems(ctx context.Context, claims *auth.UserClaims, path string, page int, itemsPerPage int, nameFilter string, timestampFilter *time.Time, onlyDirectories bool) (*storage.ListItemsResponse, error) {
 	userIdent := "unauthenticated"
 	if claims != nil {
 		userIdent = claims.Email
@@ -96,11 +96,15 @@
 			continue
 		}
 
+		if onlyDirectories && !item.IsDir() {
+			continue // Salta i file se vogliamo solo directory
+		}
+
 		itemInfo := storage.ItemInfo{
 			Name:    item.Name(),
-			IsDir:   item.IsDir(),
-			Size:    info.Size(),
-			ModTime: info.ModTime(),
-			Path:    filepath.Join(path, item.Name()),
+			IsDir:   item.IsDir(), // Sarà sempre true se onlyDirectories è true e il check sopra funziona
+			Size:    info.Size(),    // La dimensione delle directory è spesso 0 o non rilevante qui
+			ModTime: info.ModTime(), // Anche il ModTime potrebbe essere meno rilevante per le sole directory
+			Path:    filepath.Join(path, item.Name()), // Il percorso rimane importante
 		}
 
 		if nameFilter != "" {
--- a/storage/storage.go
+++ b/storage/storage.go
@@ -22,7 +22,7 @@
 	Type() string
 	Name() string
 
-	ListItems(ctx context.Context, claims *auth.UserClaims, path string, page int, itemsPerPage int, nameFilter string, timestampFilter *time.Time) (*ListItemsResponse, error)
+	ListItems(ctx context.Context, claims *auth.UserClaims, path string, page int, itemsPerPage int, nameFilter string, timestampFilter *time.Time, onlyDirectories bool) (*ListItemsResponse, error)
 	GetItem(ctx context.Context, claims *auth.UserClaims, path string) (*ItemInfo, error)
 	OpenReader(ctx context.Context, claims *auth.UserClaims, path string) (io.ReadCloser, error)
 	CreateDirectory(ctx context.Context, claims *auth.UserClaims, path string) error
--- a/websocket/websocket.go
+++ b/websocket/websocket.go
@@ -199,10 +199,11 @@
 		var payload struct {
 			StorageName     string `json:"storage_name"`
 			DirPath         string `json:"dir_path"`
-			Page            int    `json:"page"`
+			Page            int    `json:"page"` //lint:ignore U1000 Potrebbe essere usato in futuro per paginare il treeview, anche se attualmente si carica "tutto"
 			ItemsPerPage    int    `json:"items_per_page"`
 			NameFilter      string `json:"name_filter"`
 			TimestampFilter string `json:"timestamp_filter"`
+			OnlyDirectories bool   `json:"only_directories,omitempty"` // NUOVO CAMPO
 		}
 		payloadBytes, err := json.Marshal(msg.Payload)
 		if err != nil {
@@ -235,7 +236,7 @@
 			}
 		}
 
-		listResponse, err := provider.ListItems(ctx, claims, payload.DirPath, page, itemsPerPage, payload.NameFilter, tFilter)
+		listResponse, err := provider.ListItems(ctx, claims, payload.DirPath, page, itemsPerPage, payload.NameFilter, tFilter, payload.OnlyDirectories) // << AGGIUNTO payload.OnlyDirectories
 		if err != nil {
 			if errors.Is(err, storage.ErrNotFound) {
 				response.Type = "error"